# Makefile Guide for Greenova Project

## Introduction to Make

Make is a build automation tool that automatically builds executable programs
and libraries from source code by reading files called Makefiles. Make was
originally created by Stuart Feldman in 1976 at Bell Labs and remains one of
the most widely used build tools in software development [1].

Make's primary purpose is to determine which pieces of a large program need to
be recompiled and issue the commands to recompile them when necessary. However,
in modern development, Make has expanded to automate various tasks beyond
compilation.

## Makefile Fundamentals

### Basic Structure

A Makefile consists of a set of rules with the following format:

```makefile
target: prerequisites
    recipe
```

Where:

- **target**: The file to be created or action to be executed
- **prerequisites**: Files that the target depends on
- **recipe**: Commands executed to create the target or perform an action (must
  be indented with a tab)

### Example of a Simple Rule

```makefile
hello.o: hello.c
    gcc -c hello.c -o hello.o
```

### Variables

Variables in Makefiles help maintain consistency and make the file more
readable:

```makefile
CC = gcc
CFLAGS = -Wall -g

hello.o: hello.c
    $(CC) $(CFLAGS) -c hello.c -o hello.o
```

### Phony Targets

Phony targets are used for actions rather than file creation:

```makefile
.PHONY: clean
clean:
    rm -f *.o
```

## Makefiles in the Python Ecosystem

For Python projects like Greenova, Makefiles serve several purposes:

1. Managing virtual environments
2. Installing dependencies
3. Running tests
4. Code formatting and linting
5. Building documentation
6. Deployment tasks

### Example Python Project Makefile Structure

```makefile
VENV = .venv
PYTHON = $(VENV)/bin/python
PIP = $(VENV)/bin/pip
REQUIREMENTS = requirements.txt

.PHONY: venv install test clean

venv:
    python3 -m venv $(VENV)

install: venv
    $(PIP) install --upgrade pip
    $(PIP) install -r $(REQUIREMENTS)

test: install
    $(PYTHON) -m pytest

clean:
    rm -rf $(VENV) __pycache__ .pytest_cache
```

## Makefile.am and Makefile.in

These are part of the GNU Autotools build system:

- **Makefile.am**: A simplified, high-level Makefile written by developers
- **Makefile.in**: Generated by automake from Makefile.am, serving as a
  template
- **Makefile**: The final file created by configure script from Makefile.in

### When to Use Autotools

Autotools (including Makefile.am and Makefile.in) are most useful for:

1. Cross-platform C/C++ projects
2. Projects requiring complex configuration detection
3. Applications that need to work across diverse Unix-like environments

For Python projects like Greenova, standard Makefiles are usually sufficient.

## Greenova Project Makefile

The Greenova project uses a Makefile to streamline development workflows:

### Key Variables

```makefile
VENV = .venv
PYTHON = $(VENV)/bin/python
PIP = $(VENV)/bin/pip
REQUIREMENTS = requirements.txt
CONSTRAINTS = constraints.txt
DJANGO = $(PYTHON) manage.py
```

### Common Commands

| Command        | Purpose                                         |
| -------------- | ----------------------------------------------- |
| `make venv`    | Creates a Python virtual environment            |
| `make install` | Installs project dependencies                   |
| `make migrate` | Runs Django migrations                          |
| `make serve`   | Starts the development server                   |
| `make test`    | Runs the test suite                             |
| `make lint`    | Performs code quality checks                    |
| `make clean`   | Removes temporary files and virtual environment |

### Example Usage

```bash
# Initial setup
make install

# Development workflow
make migrate
make serve

# Before committing code
make lint
make test
```

## Best Practices for Makefiles

1. **Use variables**: Define paths, commands, and options as variables at the
   top of the file
2. **Declare phony targets**: Mark targets that don't represent files with
   `.PHONY`
3. **Create target dependencies**: Ensure prerequisites are built before
   targets that need them
4. **Document your Makefile**: Add comments explaining complex recipes or
   variables
5. **Keep it portable**: Use conditional logic for cross-platform compatibility
6. **Modularize**: Split complex Makefiles using include directives

## Extending the Greenova Makefile

To add a new command to the Greenova Makefile:

1. Define any necessary variables
2. Create a new target with appropriate dependencies
3. Write the recipe commands
4. Document the command in comments
5. Update this documentation

Example addition for code formatting:

```makefile
.PHONY: format

format:
    $(PYTHON) -m black .
    $(PYTHON) -m isort .
```

## Debugging Makefiles

When Makefiles don't behave as expected:

- Use `make -n` to print commands without executing them
- Use `make -d` for detailed debug information
- Add `@echo` statements in recipes to print variable values
- Use `$(info $(VARIABLE))` to debug variables during parsing

## References

[1] R. M. Stallman, R. McGrath, and P. D. Smith, "GNU Make Manual," Free
Software Foundation, 2020. [Online]. Available:
<https://www.gnu.org/software/make/manual/> [Accessed: Mar. 27, 2025].

[2] "Make (software)," Wikipedia. [Online]. Available:
<https://en.wikipedia.org/wiki/Make_(software)> [Accessed: Mar. 27, 2025].

[3] J. Graham-Cumming, "The GNU Make Book," No Starch Press, San Francisco,
CA, 2015.

[4] "Makefiles for Python Projects," Earthly Technologies, 2022. [Online].
Available: <https://earthly.dev/blog/python-makefile/> [Accessed: Mar. 27, 2025].

[5] "How to write a Makefile: Automating Python setup, compilation, and
testing," Stack Abuse, 2021. [Online]. Available:
<https://stackabuse.com/how-to-write-a-makefile-automating-python-setup-compilation-and-testing/>
[Accessed: Mar. 27, 2025].

[6] P. Ward, "Ode to GNU Make," Evan Soil, 2022. [Online]. Available:
<https://www.evan-soil.io/blog/ode-to-gnu-make/> [Accessed: Mar. 27, 2025].
